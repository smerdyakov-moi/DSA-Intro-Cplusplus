#include<iostream>
using namespace std;
#define globalSpace 5;

class  TreeNode{
    public:
        TreeNode *left; //Pointer to the left node
        TreeNode *right; // Pointer to the right node
        int data{}; // Acts as both the data and the key!

        TreeNode(){ //Default constructor
            data = 0 ;
            left = nullptr;
            right = nullptr;
        }
        TreeNode(int d){ // Parameterized constructor
            data = d;
            left=nullptr;
            right=nullptr;
        }
};

class BST{
    public:
        TreeNode *root{nullptr};

        bool isTreeEmpty(){ return (root==nullptr)? true:false; } // Tree Empty?
        void insertNode(TreeNode* t) { // Node Insertion in the binary tree
            if (root == nullptr) {
                root = t;
                cout << "Node inserted as root." << endl;
                return;
            }
            TreeNode* temp = root;
            while(true){
                if(temp->data==t->data){
                    cout<<"No duplicates allowed!"<<endl;
                    delete t;
                    return;
                }else if( t->data <temp->data){
                    if(temp->left==nullptr){
                        temp->left=t;
                        cout<<"Node added to the left of "<<temp->data<<endl;
                        return ;
                    }else{
                        temp=temp->left;
                    }
                }else{
                    if(temp->right==nullptr){
                        temp->right=t;
                        cout<<"Node added to the right of "<<temp->data<<endl;
                        return;
                    }else{
                        temp=temp->right;
                    }
                }
            }
        }
        //Depth-first search traversal method

        void printPreOrder(TreeNode *r){ //Node Display using Pre-Order Traversal(Part of Depth-first search = > N-L-R (Node->left->Right))
            if(r==nullptr){return ;}
            cout<<r->data<<" ";
            printPreOrder(r->left);
            printPreOrder(r->right);
        }
        void printInOrder(TreeNode *r){ //Node Display using In-Order Traversal(Part of Depth-first search => L-N-R)
            if(r==nullptr){return ;}
            printInOrder(r->left);
            cout<<r->data<<" ";
            printInOrder(r->right);
        }
        void printPostOrder(TreeNode *r){ //Node Display using Post-Order Traversal(Part of Depth-first search => L-R-N)
            if(r==nullptr){return ;}
            printPostOrder(r->left);
            printPostOrder(r->right);
            cout<<r->data<<" ";
        }
        
        //Checking whether the value exists in the node or not
        bool iterativeSearch(int value){
            if(root==nullptr){cout<<"Hell"<<endl; return false;}
            TreeNode*temp{root};
            while(temp!=nullptr){   
                if(temp->data==value){
                    return true;
                }else if(temp->data>value){
                    temp=temp->left;
                }else{
                    temp=temp->right;
                }
            }
            return (temp==nullptr)? false:true;
        }

        //Recursive method to find the height of the tree (Note: the height of a root node equals height of the tree, so a single root node would have 0 height)
        int heightOfTree(TreeNode* r){
            if(r==nullptr){return -1;}
            else{
                int lheight{heightOfTree(r->left)};
                int rheight(heightOfTree(r->right));
                return (lheight>rheight)? lheight+1:rheight+1;
            }
        }
        
        //BFS Traversal 
        void printLevelOrderTraversal(TreeNode *r){
            int h{heightOfTree(r)};
            for(int i{} ; i <=h ; i++ ){
                printGivenlevel(r,i);
                cout<<"\n";
            }
        }
        void printGivenlevel(TreeNode *r, int level){
            if(r==nullptr){return;}
            else if (level==0){cout<<r->data<<" ";}
            else{
                printGivenlevel(r->left,level-1);
                printGivenlevel(r->right,level-1);
            }
        }
};  

int main(){
    BST bst;
    int option,value;
    do{
        cout<<"What operation do you want to perform ?"<<endl;
        cout<<"1. Insert Node \n2. Search Node \n3. Delete Node \n4. Print BST values \n5. Height of the tree \n6. BST Traversal \n7. Exit Program\n>>";
        cin>>option;
        switch (option){
            case 1:{
                cout<<"INSERT\n"<<endl;
                cout<<"Enter value of tree node to insert in BST: ";
                cin>>value;
                TreeNode *new_node = new TreeNode(value); // Allocating memory on  the heap 
                bst.insertNode(new_node);
                break;
            }
            case 2:
                cout<<"SEARCH\n"<<endl;
                int v;
                cout<<"Enter the value you want to search in the node: ";
                cin>>v;
                if(bst.iterativeSearch(v)){
                    cout<<"Value "<<v<<" exists!"<<endl;
                }else{
                    cout<<"Value "<<v<<" does not exist:/"<<endl;
                }
                break;
            case 3:
                cout<<"DELETE\n"<<endl;
                break;
            case 4:
                cout<<"DISPLAY\n"<<endl;
                bst.printPostOrder(bst.root); //bst.printPostOrder OR bst.printInOrder
                cout<<"\n"<<endl;
                break;
            case 5:
                cout<<"Height of the tree: "<<bst.heightOfTree(bst.root)<<endl;
                break;

            case 6:
                bst.printLevelOrderTraversal(bst.root);//
                break;
            case 7:
                break;
        }
    }while(option!=7);
}
